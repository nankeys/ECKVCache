# Erasure KV Cache (Trace Replay System)

This project simulates a key-value caching system with **erasure coding** support on top of a **Memcached cluster**.  
It supports **trace-driven workload replay**, **data distribution via consistent hashing**, and **full data flush after replay**.

---

## âœ¨ Project Structure

```
ECKVCache/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ main.cpp
â”œâ”€â”€ KVStat.h
â”œâ”€â”€ KVStatReader.h / KVStatReader.cpp
â”œâ”€â”€ ErasureCacheClient.h / ErasureCacheClient.cpp
â”œâ”€â”€ TraceReplayRunner.h / TraceReplayRunner.cpp
â”œâ”€â”€ trace.txt  (example)
â”œâ”€â”€ stat.txt   (example)
```

---

## ðŸ“¦ Features

- **Stat File Parsing**  
  Read `stat.txt`, where each line is a KV description (tab-separated).
  
- **Trace Replay**  
  Read `trace.txt` access patterns (comma-separated, with timestamp and key).

- **4KB Ã— k Chunking + Erasure Coding**  
  Each KV is split into `k` data blocks, with `n-k` parity blocks generated by Intel ISA-L.

- **Consistent Hashing**  
  Sub-blocks are distributed across multiple Memcached servers via consistent hashing.

- **Asynchronous Fetch and Decoding**  
  Only the first k available chunks are needed to reconstruct original data.

- **Automatic Cleanup**  
  After a full replay, automatically flush all Memcached nodes.

---

## ðŸ“š Dependencies

- **C++17**
- **libmemcached** (client library for Memcached)
- **ISA-L** (IntelÂ® Intelligent Storage Acceleration Library)
- **CMake â‰¥ 3.10**

---

## âš¡ Building the Project

```bash
mkdir build
cd build
cmake ..
make -j
```

This will generate an executable `erasure_kv_cache`.

---

## ðŸš€ Running

Prepare your `trace.txt` and `stat.txt`, then simply run:

```bash
./erasure_kv_cache
```

The system will:
- Load KV metadata from `stat.txt`
- Preload data into Memcached
- Replay accesses from `trace.txt`
- Recover missing data using erasure coding
- Output success/failure statistics
- Flush Memcached at the end

---

## ðŸ“„ File Format Specifications

### `stat.txt`
- **Tab (`\t`) separated**
- **Fields**: `key 	 size_in_bytes 	 frequency`
- **Example**:
  ```
  user_001	4096	123
  user_002	8192	450
  ```

### `trace.txt`
- Same format from [Twitter](https://github.com/twitter/cache-trace)
- **Comma (`,`) separated**
- **Fields**: 
  + `timestamp`: the time when the cache receives the request, in sec
  + `anonymized key`: the original key with anonymization
  + `key size`: the size of key in bytes
  + `value size`: the size of value in bytes
  + `client id`: the anonymized clients (frontend service) who sends the request
  + `operation`: one of get/gets/set/add/replace/cas/append/prepend/delete/incr/decr
  + `TTL`: the time-to-live (TTL) of the object set by the client, it is 0 when the request is not a write request.
- **Example**:
  ```
    0,z44uy84G444444brpd4n44M4444F444=,32,311,4,get,0
    0,z44uy84yz901Q5dqd4nK4464444ygAn444==,36,515,6,get,0
  ```

---

## ðŸ›  Configuration

You can adjust `k` and `n` in `main.cpp`:

```cpp
int k = 6;
int n = 10;
```

You can configure multiple Memcached servers:

```cpp
std::vector<std::string> servers = { "127.0.0.1", "192.168.1.2" };
ErasureCacheClient client(servers, k, n);
```

---

## ðŸ“ˆ Future Improvements

- Parallel recovery of multiple keys
- Support weighted consistent hashing
- Add memory usage and latency profiling
- Implement partial failure simulation (loss of chunks)

---

## ðŸ“‹ License

This project is for **academic and research use only**.
